{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Getting Started \u00b6 The Mobile.BuildTools is an easy to use NuGet package that adds new MSBuild targets to your build pipeline. In essence it teaches MSBuild some new tricks to help make your DevOps easier and help you follow better practices while developing your application. The bulk of support is around Xamarin.Android and Xamarin.iOS and it will work regardless of whether you are using the native tooling, Xamarin.Forms, or Uno to create your UI. The Mobile.BuildTools are a collection of MSBuild Tasks that help make MSBuild smarter in handling the build process for CI/CD with Mobile Applications. The library was born from a desire to share build processes from one app to the next without having to copy and paste a bunch of build scripts each of which could easily end up out of date. Because the Mobile.BuildTools simply provides MSBuild Tasks, this adds nothing to the size of your application and if being used on a project that will be packed and shared, you can set the PackageReference's PrivateAssets to all. Support \u00b6 This project is maintained by Dan Siegel. If this project has helped you please consider sponsoring Dan on GitHub. Your contributions help make great open source projects possible. Latest NuGet's \u00b6 Package NuGet SponsorConnect Mobile.BuildTools Mobile.BuildTools.Configuration Want to consume the CI packages? Sign up as a GitHub sponsor and you can access the Sponsor Connect private feed. What does it do? \u00b6 Automatic app bundle copy to artifacts folder in the Solution directory On iOS this copies your IPA + dSYM On Android this copies your APK / AAB Automatically update the app version Configurable for local, build host or both Configurable to use timestamp or BuildId if it exists + user defined Offset Tokenize your Info.plist / AndroidManifest.xml ( $$SomeKey$$ ) Tokens replaced at build in obj to protect any against configuration values being checked in Support for SCSS files to generate Xamarin.Forms CSS files Generate 'Secrets' class at build that contains any configuration or application secrets Supports all primitive data types + Uri, DateTime, DateTimeOffset, TimeStamp, & Guid Any property can be made an array of values (useful for feature flags or OAuth scopes) ConfigurationManager with app.config Optimized for Mobile with familiar Static API and Interface based Singleton Offers Opt-In API for doing runtime transformations and bundling app.config's App.config transformations at build Optionally bundle all config's or config's with Non-Standard environment (i.e. not Debug, Release) Simplified Image Handling (Android, iOS, macOS, tvOS) Ability to store single high resolution images in one or more directories Ability to conditionally include images in directories based on the build target (i.e. iOS or Android) Ability to conditionally include images in directories based on the build configuration (i.e. Debug or !Debug) Ability to include images that may only be used as an overlay for another image. Ability to Draw Banner on images (i.e. Dev, Debug, Free, Pro) User controlled Text User controlled Text color & Font from System Font or local font file User control Banner color.. can include a single color for a solid look, or multiple colors for a gradient Ability to generate additional outputs for a single input image Ability add padding around an image Ability to add a background color to a transparent image Supports PNG & JPG file types Support for SVG and Gif (Planned) Release Notes generation Customizable output based on latest commit messages (Planned) Support for user templating and Flag based messages since last release/Git Tag... (i.e. [Bug][iOS] Some bug got fixed ) Additional Notes \u00b6 Some additional notes... the Mobile.BuildTools will help with some advanced scenarios like: Generating app bundles that have different ID's for different environments White Labeling Use the Secrets to generate Feature Flags Generate Free or Lite versions of your app along with a Pro version Using the image api you could have a single input image and generate each of the following All of the outputs defined for the AppIcon iconset on iOS A typical BundleResource 1x, 2x, 3x for using in your SplashScreen storyboard A typical Drawable for you a splash screen activity (ldpi, mdpi, hdpi, xhdpi, xxhdpi, xxxhdpi) The smaller icon file in the mipmap folders (ldpi, mdpi, hdpi, xhdpi, xxhdpi, xxxhdpi) The larger launcher_foreground file in the mipmap folders (ldpi, mdpi, hdpi, xhdpi, xxhdpi, xxxhdpi)","title":"Getting Started"},{"location":"#getting-started","text":"The Mobile.BuildTools is an easy to use NuGet package that adds new MSBuild targets to your build pipeline. In essence it teaches MSBuild some new tricks to help make your DevOps easier and help you follow better practices while developing your application. The bulk of support is around Xamarin.Android and Xamarin.iOS and it will work regardless of whether you are using the native tooling, Xamarin.Forms, or Uno to create your UI. The Mobile.BuildTools are a collection of MSBuild Tasks that help make MSBuild smarter in handling the build process for CI/CD with Mobile Applications. The library was born from a desire to share build processes from one app to the next without having to copy and paste a bunch of build scripts each of which could easily end up out of date. Because the Mobile.BuildTools simply provides MSBuild Tasks, this adds nothing to the size of your application and if being used on a project that will be packed and shared, you can set the PackageReference's PrivateAssets to all.","title":"Getting Started"},{"location":"#support","text":"This project is maintained by Dan Siegel. If this project has helped you please consider sponsoring Dan on GitHub. Your contributions help make great open source projects possible.","title":"Support"},{"location":"#latest-nugets","text":"Package NuGet SponsorConnect Mobile.BuildTools Mobile.BuildTools.Configuration Want to consume the CI packages? Sign up as a GitHub sponsor and you can access the Sponsor Connect private feed.","title":"Latest NuGet's"},{"location":"#what-does-it-do","text":"Automatic app bundle copy to artifacts folder in the Solution directory On iOS this copies your IPA + dSYM On Android this copies your APK / AAB Automatically update the app version Configurable for local, build host or both Configurable to use timestamp or BuildId if it exists + user defined Offset Tokenize your Info.plist / AndroidManifest.xml ( $$SomeKey$$ ) Tokens replaced at build in obj to protect any against configuration values being checked in Support for SCSS files to generate Xamarin.Forms CSS files Generate 'Secrets' class at build that contains any configuration or application secrets Supports all primitive data types + Uri, DateTime, DateTimeOffset, TimeStamp, & Guid Any property can be made an array of values (useful for feature flags or OAuth scopes) ConfigurationManager with app.config Optimized for Mobile with familiar Static API and Interface based Singleton Offers Opt-In API for doing runtime transformations and bundling app.config's App.config transformations at build Optionally bundle all config's or config's with Non-Standard environment (i.e. not Debug, Release) Simplified Image Handling (Android, iOS, macOS, tvOS) Ability to store single high resolution images in one or more directories Ability to conditionally include images in directories based on the build target (i.e. iOS or Android) Ability to conditionally include images in directories based on the build configuration (i.e. Debug or !Debug) Ability to include images that may only be used as an overlay for another image. Ability to Draw Banner on images (i.e. Dev, Debug, Free, Pro) User controlled Text User controlled Text color & Font from System Font or local font file User control Banner color.. can include a single color for a solid look, or multiple colors for a gradient Ability to generate additional outputs for a single input image Ability add padding around an image Ability to add a background color to a transparent image Supports PNG & JPG file types Support for SVG and Gif (Planned) Release Notes generation Customizable output based on latest commit messages (Planned) Support for user templating and Flag based messages since last release/Git Tag... (i.e. [Bug][iOS] Some bug got fixed )","title":"What does it do?"},{"location":"#additional-notes","text":"Some additional notes... the Mobile.BuildTools will help with some advanced scenarios like: Generating app bundles that have different ID's for different environments White Labeling Use the Secrets to generate Feature Flags Generate Free or Lite versions of your app along with a Pro version Using the image api you could have a single input image and generate each of the following All of the outputs defined for the AppIcon iconset on iOS A typical BundleResource 1x, 2x, 3x for using in your SplashScreen storyboard A typical Drawable for you a splash screen activity (ldpi, mdpi, hdpi, xhdpi, xxhdpi, xxxhdpi) The smaller icon file in the mipmap folders (ldpi, mdpi, hdpi, xhdpi, xxhdpi, xxxhdpi) The larger launcher_foreground file in the mipmap folders (ldpi, mdpi, hdpi, xhdpi, xxhdpi, xxxhdpi)","title":"Additional Notes"},{"location":"credits/","text":"While the Mobile.BuildTools does not add any external dependencies to your projects, we could not do what we do without being able to build on the hard work from other projects. Though the Mobile.BuildTools is licensed under the MIT License, some of our dependencies use alternate Open Source licenses. Project License GitHub MSBuild MIT microsoft/msbuild Newtonsoft.Json MIT JamesNK/Newtonsoft.Json Microsoft.Web.Xdt* Apache aspnet/xdt SixLabors.ImageSharp Apache SixLabors/ImageSharp/ Note Microsoft.Web.Xdt is the only reference added to projects, if using the Mobile.BuildTools.Configuration package. There is never any bloat added by the core Mobile.BuildTools package to your applications. Despite being from the aspnet team this package does not bring in any additional references.","title":"Credits"},{"location":"faq/","text":"F.A.Q. \u00b6 Should every value in my Secrets be \"Secret\"? \u00b6 The Secrets Class is a great way to prevent security vulnerabilities created from checking into source control things like Client Id's, Consumer Secrets, or Connection Strings. But it really doesn't have to stop there. In fact the Secrets class is a great way of setting the configuration environment for your application at build. Should your build point to the Dev, Stage, or Production API? This is also a great way of being very intentional about it. Does the Secrets class have to be in the Helpers namespace or named Secrets? \u00b6 In short no it does not. This has always been configurable though it is much easier with version 2.0 as you can just update the Configuration for the project. See the Secrets Configuration topic for more information on how to configure this for version 2. Do all of the things that the Mobile.BuildTools is capable of execute every time I run a build? \u00b6 We try to be smart about what we will and will not do. There is an initialization task that will run on each build which evaluates your project to determine if certain things should or should not occur. For instance if there are no SCSS files in your project that Target will not fire, similarly if you have disabled a target explicitly it should be skipped during the build. I installed the Mobile.BuildTools why can't I access the ConfigurationManager? \u00b6 We explicitly separated the ConfigurationManager from the Mobile.BuildTools as we recognize that not everyone will want to use this feature. In order to get the build time transformations you will need to have the Mobile.BuildTools installed in your platform projects, however you will need the Mobile.BuildTools.Configuration package installed in any project where you want to use the ConfigurationManager.","title":"F.A.Q."},{"location":"faq/#faq","text":"","title":"F.A.Q."},{"location":"faq/#should-every-value-in-my-secrets-be-secret","text":"The Secrets Class is a great way to prevent security vulnerabilities created from checking into source control things like Client Id's, Consumer Secrets, or Connection Strings. But it really doesn't have to stop there. In fact the Secrets class is a great way of setting the configuration environment for your application at build. Should your build point to the Dev, Stage, or Production API? This is also a great way of being very intentional about it.","title":"Should every value in my Secrets be \"Secret\"?"},{"location":"faq/#does-the-secrets-class-have-to-be-in-the-helpers-namespace-or-named-secrets","text":"In short no it does not. This has always been configurable though it is much easier with version 2.0 as you can just update the Configuration for the project. See the Secrets Configuration topic for more information on how to configure this for version 2.","title":"Does the Secrets class have to be in the Helpers namespace or named Secrets?"},{"location":"faq/#do-all-of-the-things-that-the-mobilebuildtools-is-capable-of-execute-every-time-i-run-a-build","text":"We try to be smart about what we will and will not do. There is an initialization task that will run on each build which evaluates your project to determine if certain things should or should not occur. For instance if there are no SCSS files in your project that Target will not fire, similarly if you have disabled a target explicitly it should be skipped during the build.","title":"Do all of the things that the Mobile.BuildTools is capable of execute every time I run a build?"},{"location":"faq/#i-installed-the-mobilebuildtools-why-cant-i-access-the-configurationmanager","text":"We explicitly separated the ConfigurationManager from the Mobile.BuildTools as we recognize that not everyone will want to use this feature. In order to get the build time transformations you will need to have the Mobile.BuildTools installed in your platform projects, however you will need the Mobile.BuildTools.Configuration package installed in any project where you want to use the ConfigurationManager.","title":"I installed the Mobile.BuildTools why can't I access the ConfigurationManager?"},{"location":"release-notes/","text":"Release Notes \u00b6 Generating Release notes can be painful. The Mobile.BuildTools will help solve this problem in v2.X with the Release Notes Task. For this we will generate a ReleaseNotes.txt automatically for you. The configuration options are shown here with their default values. { \"$schema\" : \"https://mobilebuildtools.com/schemas/v2/buildtools.schema.json\" , \"releaseNotes\" : { \"maxDays\" : 7 , \"maxCommit\" : 10 , \"characterLimit\" : 250 , \"filename\" : \"ReleaseNotes.txt\" , \"createInRoot\" : true , \"disable\" : false } }","title":"Release Note Generation"},{"location":"release-notes/#release-notes","text":"Generating Release notes can be painful. The Mobile.BuildTools will help solve this problem in v2.X with the Release Notes Task. For this we will generate a ReleaseNotes.txt automatically for you. The configuration options are shown here with their default values. { \"$schema\" : \"https://mobilebuildtools.com/schemas/v2/buildtools.schema.json\" , \"releaseNotes\" : { \"maxDays\" : 7 , \"maxCommit\" : 10 , \"characterLimit\" : 250 , \"filename\" : \"ReleaseNotes.txt\" , \"createInRoot\" : true , \"disable\" : false } }","title":"Release Notes"},{"location":"appendix/aps/","text":"Apple Push Notifications \u00b6 When using Push Notifications on iOS you must be sure to set the aps-environment from development to production before submitting to the App Store. The Mobile.BuildTools will handle this for you easily at build. Critical Note While this was originally slated for v2.0, this will not be done until 2.1. From the Build Definition \u00b6 You can accomplish this easily by updating your build definition to pass additional MSBuild arguments with the value /p:APSProductionEnvironment=true and the Mobile.BuildTools will automatically update the aps-environment for you. - task : XamariniOS@2 inputs : solutionFile : '**/*.sln' configuration : 'Store' packageApp : true runNugetRestore : false args : '/p:APSProductionEnvironment=true' From the MSBuild Properties \u00b6 You can alternatively do this through any Directory.Build.props or in the csproj of your iOS project by adding the following: <PropertyGroup Condition= \" $(Configuration) == 'Store' \" > <APSProductionEnvironment> true </APSProductionEnvironment> </PropertyGroup>","title":"Apple Push Notifications"},{"location":"appendix/aps/#apple-push-notifications","text":"When using Push Notifications on iOS you must be sure to set the aps-environment from development to production before submitting to the App Store. The Mobile.BuildTools will handle this for you easily at build. Critical Note While this was originally slated for v2.0, this will not be done until 2.1.","title":"Apple Push Notifications"},{"location":"appendix/aps/#from-the-build-definition","text":"You can accomplish this easily by updating your build definition to pass additional MSBuild arguments with the value /p:APSProductionEnvironment=true and the Mobile.BuildTools will automatically update the aps-environment for you. - task : XamariniOS@2 inputs : solutionFile : '**/*.sln' configuration : 'Store' packageApp : true runNugetRestore : false args : '/p:APSProductionEnvironment=true'","title":"From the Build Definition"},{"location":"appendix/aps/#from-the-msbuild-properties","text":"You can alternatively do this through any Directory.Build.props or in the csproj of your iOS project by adding the following: <PropertyGroup Condition= \" $(Configuration) == 'Store' \" > <APSProductionEnvironment> true </APSProductionEnvironment> </PropertyGroup>","title":"From the MSBuild Properties"},{"location":"appendix/json-schemas/","text":"The Mobile.BuildTools relies a lot on JSON configurations because JSON is easy for most developers to work with. FileName Schema Url secrets.json n/a - JSON Dictionary manifest.json n/a - JSON Dictionary buildtools.json https://mobilebuildtools.com/schemas/v2/buildtools.schema.json {imageName}.json https://mobilebuildtools.com/schemas/v2/resourceDefinition.schema.json","title":"JSON Schemas"},{"location":"appendix/msbuild-props/","text":"MSBuild Properties \u00b6 The Mobile.BuildTools additionally provides a number of MSBuild Properties to further assist advanced developers in creating advanced build pipelines. PropertyName Description IsWindows IsUnix Indicates that you are running on a Linux or macOS build agent PowerShellExe returns the default path for the exe IsAndroidProject Indicates the current Target Framework is MonoAndroid IsiOSProject Indicates the current Target Framework is Xamarin.iOS IsUWPProject Indicates the current Target Framework is UAP IsMacOSProject Indicates the current Target Framework is Xamarin.Mac IsTizenProject Indicates the current Target Framework is Tizen BuildToolsArtifactOutputPath Will default to the Solution Directory in the App folder. In Azure DevOps it will default to the Build.ArtifactStagingDirectory again in the App folder. IsAppCenter Indicates that the AppCenter Build Id has been set IsAzureDevOps Indicates that the variable BUILD_BUILDNUMBER has been set. This may indicate true when building on certain other CI systems. IsAppVeyor Indicates that the AppVeyor Build Number has been set. IsJenkins Indicates that a Build Number has been set but there is no Team City Version IsTeamCity Indicates that a Build Number has been set and there is also a Team City Version set. IsBuildHost If any of the above CI Platforms return true this will indicate true as well.","title":"MSBuild Properties"},{"location":"appendix/msbuild-props/#msbuild-properties","text":"The Mobile.BuildTools additionally provides a number of MSBuild Properties to further assist advanced developers in creating advanced build pipelines. PropertyName Description IsWindows IsUnix Indicates that you are running on a Linux or macOS build agent PowerShellExe returns the default path for the exe IsAndroidProject Indicates the current Target Framework is MonoAndroid IsiOSProject Indicates the current Target Framework is Xamarin.iOS IsUWPProject Indicates the current Target Framework is UAP IsMacOSProject Indicates the current Target Framework is Xamarin.Mac IsTizenProject Indicates the current Target Framework is Tizen BuildToolsArtifactOutputPath Will default to the Solution Directory in the App folder. In Azure DevOps it will default to the Build.ArtifactStagingDirectory again in the App folder. IsAppCenter Indicates that the AppCenter Build Id has been set IsAzureDevOps Indicates that the variable BUILD_BUILDNUMBER has been set. This may indicate true when building on certain other CI systems. IsAppVeyor Indicates that the AppVeyor Build Number has been set. IsJenkins Indicates that a Build Number has been set but there is no Team City Version IsTeamCity Indicates that a Build Number has been set and there is also a Team City Version set. IsBuildHost If any of the above CI Platforms return true this will indicate true as well.","title":"MSBuild Properties"},{"location":"appendix/upgrade/","text":"Upgrading from 1.X \u00b6 The Mobile.BuildTools 1.X is extremely reliable for generating app secrets! But 2.0 is much better at it. There were a number of factors that went into determining what we should and should not be doing. Secrets \u00b6 There is a lot about the Secrets class generation that has been completely refactored. The result is that you have far more options when generating secrets than you did in 1.X. The big thing to consider is that you will need to add a configuration for the Project in the solution you want to add secrets for.","title":"Upgrading from 1.X"},{"location":"appendix/upgrade/#upgrading-from-1x","text":"The Mobile.BuildTools 1.X is extremely reliable for generating app secrets! But 2.0 is much better at it. There were a number of factors that went into determining what we should and should not be doing.","title":"Upgrading from 1.X"},{"location":"appendix/upgrade/#secrets","text":"There is a lot about the Secrets class generation that has been completely refactored. The result is that you have far more options when generating secrets than you did in 1.X. The big thing to consider is that you will need to add a configuration for the Project in the solution you want to add secrets for.","title":"Secrets"},{"location":"config/","text":"App Configuration for Mobile Projects \u00b6 Mobile Apps unlike traditional Desktop and Web projects are limiting for developers because you must define configuration values at build and not on deployment. The Mobile.BuildTools is here to help you solve this problem and meet you where you are. Developers have different needs at different times. For v1.X, the Mobile.BuildTools took the very opinionated idea that configuration values and app secrets should be treaded as something that should be strongly typed. This has a few advantages that come from errors surfacing at build time rather than runtime. Sometimes though it may be more desireable to perform quick swaps from one environment to another where you are certain that you are running the same exact tested binary build as you have previously. For this reason starting with v2.0 you will have support for using an app.config to provide you the same sort of configurations support that you may be used to from Desktop development or from the web.config varient with ASP.NET development.","title":"Intro"},{"location":"config/#app-configuration-for-mobile-projects","text":"Mobile Apps unlike traditional Desktop and Web projects are limiting for developers because you must define configuration values at build and not on deployment. The Mobile.BuildTools is here to help you solve this problem and meet you where you are. Developers have different needs at different times. For v1.X, the Mobile.BuildTools took the very opinionated idea that configuration values and app secrets should be treaded as something that should be strongly typed. This has a few advantages that come from errors surfacing at build time rather than runtime. Sometimes though it may be more desireable to perform quick swaps from one environment to another where you are certain that you are running the same exact tested binary build as you have previously. For this reason starting with v2.0 you will have support for using an app.config to provide you the same sort of configurations support that you may be used to from Desktop development or from the web.config varient with ASP.NET development.","title":"App Configuration for Mobile Projects"},{"location":"config/app.config/","text":"App.config \u00b6 The Mobile.BuildTools now includes support for using an app.config. It's important to note that we do not use the System.Configuration.ConfigurationManager, and instead use a lightweight custom implementation that allows you to initialize custom configurations at runtime which may not follow the typical app.config naming or perform transformations at runtime though this is generally not a good practice. By default Mobile.BuildTools will look for any file in the root of the head project named app.config or app.*.config. All of those files will be bundled automatically into the native app. If your file has an environment config for the build configuration such as app.debug.config this will perform a transform during build on the bundled app.config. { \"$schema\" : \"https://mobilebuildtools.com/schemas/v2/buildtools.schema.json\" , \"appConfig\" : { \"strategy\" : \"TransformOnly\" } } Note By default the Mobile.BuildTools will only bundle the transformed app.config into your project. You can optionally set the strategy to BundleAll or BundleNonStandard if you require runtime transformations. App Config Strategy \u00b6 Strategy Description TransformOnly This the default strategy which will perform the transformation and only bundle a single transformed app.config into your project. BundleAll When set as the app config strategy this will bundle any app.config that you may have such as app.debug.config or app.release.config BundleNonStandard When set as the app config strategy this will limit bundled app config's to any that are not for standard Xamarin build configurations which include Debug, Release, Store, & AdHoc. Note All file names are compared ignoring case. Supported Platforms \u00b6 Platform Supported NetStandard Yes NetCoreApp 3.1 Xamarin.iOS Yes MonoAndroid 8.0+ UWP* 16299+ Xamarin.Mac* Yes Xamarin.TVOS* Yes Tizen* Yes Note Platform's with an asterisk have not been tested explicitly. F.A.Q. \u00b6 Q. Can I use the ConfigurationManager without using the Mobile.BuildTools? A. Yes you absolutely can. The AppConfigSample project in the samples folder does exactly that! Q. How do I use the Environments? A. By default Environments are disabled. This means that we will only copy the transformed app.config into your project and the ConfigurationManager will only read the primary app.config.","title":"Intro"},{"location":"config/app.config/#appconfig","text":"The Mobile.BuildTools now includes support for using an app.config. It's important to note that we do not use the System.Configuration.ConfigurationManager, and instead use a lightweight custom implementation that allows you to initialize custom configurations at runtime which may not follow the typical app.config naming or perform transformations at runtime though this is generally not a good practice. By default Mobile.BuildTools will look for any file in the root of the head project named app.config or app.*.config. All of those files will be bundled automatically into the native app. If your file has an environment config for the build configuration such as app.debug.config this will perform a transform during build on the bundled app.config. { \"$schema\" : \"https://mobilebuildtools.com/schemas/v2/buildtools.schema.json\" , \"appConfig\" : { \"strategy\" : \"TransformOnly\" } } Note By default the Mobile.BuildTools will only bundle the transformed app.config into your project. You can optionally set the strategy to BundleAll or BundleNonStandard if you require runtime transformations.","title":"App.config"},{"location":"config/app.config/#app-config-strategy","text":"Strategy Description TransformOnly This the default strategy which will perform the transformation and only bundle a single transformed app.config into your project. BundleAll When set as the app config strategy this will bundle any app.config that you may have such as app.debug.config or app.release.config BundleNonStandard When set as the app config strategy this will limit bundled app config's to any that are not for standard Xamarin build configurations which include Debug, Release, Store, & AdHoc. Note All file names are compared ignoring case.","title":"App Config Strategy"},{"location":"config/app.config/#supported-platforms","text":"Platform Supported NetStandard Yes NetCoreApp 3.1 Xamarin.iOS Yes MonoAndroid 8.0+ UWP* 16299+ Xamarin.Mac* Yes Xamarin.TVOS* Yes Tizen* Yes Note Platform's with an asterisk have not been tested explicitly.","title":"Supported Platforms"},{"location":"config/app.config/#faq","text":"Q. Can I use the ConfigurationManager without using the Mobile.BuildTools? A. Yes you absolutely can. The AppConfigSample project in the samples folder does exactly that! Q. How do I use the Environments? A. By default Environments are disabled. This means that we will only copy the transformed app.config into your project and the ConfigurationManager will only read the primary app.config.","title":"F.A.Q."},{"location":"config/app.config/in-code/","text":"Using It In Code \u00b6 Note that all values from the AppSettings are strings by default. Any conversions will need to be handled in your code. var foo = ConfigurationManager . AppSettings [ \"Foo\" ]; Initialization \u00b6 Before using the ConfigurationManager you must initialize it. AppDelegate.cs public override bool FinishedLaunching ( UIApplication app , NSDictionary options ) { ConfigurationManager . Init (); global :: Xamarin . Forms . Forms . Init (); LoadApplication ( new App ()); return base . FinishedLaunching ( app , options ); } MainActivity.cs protected override void OnCreate ( Bundle bundle ) { TabLayoutResource = Resource . Layout . Tabbar ; ToolbarResource = Resource . Layout . Toolbar ; base . OnCreate ( bundle ); ConfigurationManager . Init ( this ); global :: Xamarin . Forms . Forms . Init ( this , bundle ); LoadApplication ( new App ()); } Transformations \u00b6 While the Mobile.BuildTools will automatically perform transformations at Build, runtime transformations are also supported for those scenarios where you may need to change environments for whatever business reason. For this let's consider that we have app.config and app.foo.config . We can transform to the Foo environment as follows: var foo = ConfigurationManager . AppSettings [ \"foo\" ]; // My Foo ConfigurationManager . Transform ( \"foo\" ); // This is not case sensitive foo = ConfigurationManager . AppSettings [ \"foo\" ]; // Transformed Value To convert back you can simply call: ConfigurationManager . Reset (); Note In order to Transform the values in the ConfigurationManager at Runtime the ConfigurationManager must be initialized with the enableRuntimeEnvironments parameter set to true. ConfigurationManager.Init(true) Note Calling Transform for an Environment that does not exist will not throw an error, it will however call Reset to restore the ConfigurationManager to it's original state. Testability \u00b6 The ConfigurationManager is Interface based and utilizes a Singleton. The singleton remains constant as long as ConfigurationManager.Init() is not called. You can Reset or Transform as often as you need. As a best practice it is recommended that you register the ConfigurationManager.Current instance with a Dependency Injection container and inject the IConfigurationManager into your code. This will allow you to mock the ConfigurationManager and better test your code.","title":"In Code"},{"location":"config/app.config/in-code/#using-it-in-code","text":"Note that all values from the AppSettings are strings by default. Any conversions will need to be handled in your code. var foo = ConfigurationManager . AppSettings [ \"Foo\" ];","title":"Using It In Code"},{"location":"config/app.config/in-code/#initialization","text":"Before using the ConfigurationManager you must initialize it. AppDelegate.cs public override bool FinishedLaunching ( UIApplication app , NSDictionary options ) { ConfigurationManager . Init (); global :: Xamarin . Forms . Forms . Init (); LoadApplication ( new App ()); return base . FinishedLaunching ( app , options ); } MainActivity.cs protected override void OnCreate ( Bundle bundle ) { TabLayoutResource = Resource . Layout . Tabbar ; ToolbarResource = Resource . Layout . Toolbar ; base . OnCreate ( bundle ); ConfigurationManager . Init ( this ); global :: Xamarin . Forms . Forms . Init ( this , bundle ); LoadApplication ( new App ()); }","title":"Initialization"},{"location":"config/app.config/in-code/#transformations","text":"While the Mobile.BuildTools will automatically perform transformations at Build, runtime transformations are also supported for those scenarios where you may need to change environments for whatever business reason. For this let's consider that we have app.config and app.foo.config . We can transform to the Foo environment as follows: var foo = ConfigurationManager . AppSettings [ \"foo\" ]; // My Foo ConfigurationManager . Transform ( \"foo\" ); // This is not case sensitive foo = ConfigurationManager . AppSettings [ \"foo\" ]; // Transformed Value To convert back you can simply call: ConfigurationManager . Reset (); Note In order to Transform the values in the ConfigurationManager at Runtime the ConfigurationManager must be initialized with the enableRuntimeEnvironments parameter set to true. ConfigurationManager.Init(true) Note Calling Transform for an Environment that does not exist will not throw an error, it will however call Reset to restore the ConfigurationManager to it's original state.","title":"Transformations"},{"location":"config/app.config/in-code/#testability","text":"The ConfigurationManager is Interface based and utilizes a Singleton. The singleton remains constant as long as ConfigurationManager.Init() is not called. You can Reset or Transform as often as you need. As a best practice it is recommended that you register the ConfigurationManager.Current instance with a Dependency Injection container and inject the IConfigurationManager into your code. This will allow you to mock the ConfigurationManager and better test your code.","title":"Testability"},{"location":"config/app.config/transformations/","text":"Transformations \u00b6 A basic app config may look like: <?xml version=\"1.0\" encoding=\"utf-8\" ?> <configuration> <appSettings> <add key= \"foo\" value= \"my foo\" /> <add key= \"bar\" value= \"my bar\" /> </appSettings> <connectionStrings> <add name= \"test\" providerName= \"my provider\" connectionString= \"my connection string\" /> </connectionStrings> </configuration> A Transformation config may look like: <?xml version=\"1.0\" encoding=\"utf-8\" ?> <configuration xmlns:xdt= \"http://schemas.microsoft.com/XML-Document-Transform\" > <appSettings> <add key= \"foo\" value= \"transformed\" xdt:Transform= \"Replace\" /> <add key= \"Environment\" value= \"Dev\" xdt:Transform= \"Insert \" /> </appSettings> </configuration> After running the transform from either the automatic build task, at runtime or with the .NET CLI Tool the resulting app.config will look like: <?xml version=\"1.0\" encoding=\"utf-8\" ?> <configuration> <appSettings> <add key= \"foo\" value= \"transformed\" /> <add key= \"bar\" value= \"my bar\" /> <add key= \"Environment\" value= \"Dev\" /> </appSettings> <connectionStrings> <add name= \"test\" providerName= \"my provider\" connectionString= \"my connection string\" /> </connectionStrings> </configuration> While the XDT namespace allows you to radically change your app.config. In most cases however you will only need to focus on the xdt:Transform attribute. Replace Insert InsertBefore(XPath expression) InsertAfter(XPath expression) Remove Remove All","title":"Transformations"},{"location":"config/app.config/transformations/#transformations","text":"A basic app config may look like: <?xml version=\"1.0\" encoding=\"utf-8\" ?> <configuration> <appSettings> <add key= \"foo\" value= \"my foo\" /> <add key= \"bar\" value= \"my bar\" /> </appSettings> <connectionStrings> <add name= \"test\" providerName= \"my provider\" connectionString= \"my connection string\" /> </connectionStrings> </configuration> A Transformation config may look like: <?xml version=\"1.0\" encoding=\"utf-8\" ?> <configuration xmlns:xdt= \"http://schemas.microsoft.com/XML-Document-Transform\" > <appSettings> <add key= \"foo\" value= \"transformed\" xdt:Transform= \"Replace\" /> <add key= \"Environment\" value= \"Dev\" xdt:Transform= \"Insert \" /> </appSettings> </configuration> After running the transform from either the automatic build task, at runtime or with the .NET CLI Tool the resulting app.config will look like: <?xml version=\"1.0\" encoding=\"utf-8\" ?> <configuration> <appSettings> <add key= \"foo\" value= \"transformed\" /> <add key= \"bar\" value= \"my bar\" /> <add key= \"Environment\" value= \"Dev\" /> </appSettings> <connectionStrings> <add name= \"test\" providerName= \"my provider\" connectionString= \"my connection string\" /> </connectionStrings> </configuration> While the XDT namespace allows you to radically change your app.config. In most cases however you will only need to focus on the xdt:Transform attribute. Replace Insert InsertBefore(XPath expression) InsertAfter(XPath expression) Remove Remove All","title":"Transformations"},{"location":"config/secrets/basics/","text":"App Secrets \u00b6 The Secrets class is autogenerated from a secrets.json file. This must be a simple Dictionary of keys and values. { \"ClientId\" : \"{client id}\" , \"ClientSecret\" : \"{client secret}\" } Critical Note Be sure to add the secrets.json to your .gitignore. If this is accidentally checked into source control it negates the entire purpose of use the Secrets from the Mobile.BuildTools!","title":"Basics"},{"location":"config/secrets/basics/#app-secrets","text":"The Secrets class is autogenerated from a secrets.json file. This must be a simple Dictionary of keys and values. { \"ClientId\" : \"{client id}\" , \"ClientSecret\" : \"{client secret}\" } Critical Note Be sure to add the secrets.json to your .gitignore. If this is accidentally checked into source control it negates the entire purpose of use the Secrets from the Mobile.BuildTools!","title":"App Secrets"},{"location":"config/secrets/configuration/","text":"Configuration for Secrets is a little bit different and required for v2. This provides a few benefits. It solves the issue of case sensitivity in which some build agents like to run ToUpper() on all variable names making it utterly impossible to properly generate the secrets.json properly without a script. It makes things just a little less magical so that other developers can more quickly generate the secrets.json in the appropriate projects to get started. It makes it possible to support more property types as v2.X now supports all primitives, Uri, Guid, TimeSpan, DateTime, & DateTimeOffset, plus the option to use an array for any property type. We can configure the secrets for all of the projects in our solution by providing a value with the Project name and the appropriate configuration in the buildtools.json which should be located in the same directory as our solution file. Note that the following configuration will enable the Secrets task to run for a project named AwesomeApp in your solution. All other projects in the solution will not run the Secrets tasks. { \"$schema\" : \"https://mobilebuildtools.com/schemas/v2/buildtools.schema.json\" , \"projectSecrets\" : { \"AwesomeApp\" : { \"delimiter\" : \";\" , \"disable\" : false , \"className\" : \"Secrets\" , \"namespace\" : \"Helpers\" , \"properties\" : [ { \"name\" : \"SampleString\" , \"type\" : \"String\" , \"isArray\" : false }, { \"name\" : \"SampleBool\" , \"type\" : \"bool\" , \"isArray\" : false }, { \"name\" : \"SampleInt\" , \"type\" : \"int\" , \"isArray\" : false }, { \"name\" : \"SampleDouble\" , \"type\" : \"double\" , \"isArray\" : false }, { \"name\" : \"SampleUri\" , \"type\" : \"Uri\" , \"isArray\" : false }, { \"name\" : \"SampleDateTime\" , \"type\" : \"DateTime\" , \"isArray\" : false }, ] } } Note The configuration shown here is verbose. As long as the Properties are specified with a name and type the rest of the values shown here will default to the values shown. Info If you wish to entirely disable the build task from even running in the MSBuild pipeline for a particular project you should specify the project name and set disable to true .","title":"Configuration"},{"location":"continuous-integration/platforms/","text":"Build Platforms \u00b6 Because the Mobile.BuildTools is a collection of MSBuild Targets, it works absolutely everywhere that MSBuild is available and building your project. It doesn't matter if you use Cake, or CLI scripts, or which CI platform you use. In general all of the common CI Platforms that Xamarin Developers might use are covered this includes: App Center Azure DevOps Appveyor Jenkins","title":"Platforms"},{"location":"continuous-integration/platforms/#build-platforms","text":"Because the Mobile.BuildTools is a collection of MSBuild Targets, it works absolutely everywhere that MSBuild is available and building your project. It doesn't matter if you use Cake, or CLI scripts, or which CI platform you use. In general all of the common CI Platforms that Xamarin Developers might use are covered this includes: App Center Azure DevOps Appveyor Jenkins","title":"Build Platforms"},{"location":"continuous-integration/setup/","text":"Continuous Integration Setup \u00b6 Obviously if we checked in a json file with our secrets it would negate the entire point of trying to secure our code base. The Build Tools include a Build Host Secrets task that executes prior to the Secrets Generation. This task will execute when the secrets json file does not exist in an attempt to generate the missing json file. This is designed to handle secrets across multiple projects. By default we assume you have a single shared project such as a .NET Standard library, and one or more platform projects like iOS, Android, UWP, macOS, & Tizen. To override the secrets prefix for any project you simply need to provide a value for BuildHostSecretPrefix Platform Secrets Prefix Android DroidSecret_ iOS iOSSecret_ UWP UWPSecret_ macOS MacSecret_ Tizen TizenSecret_ Default Secret_","title":"Setup"},{"location":"continuous-integration/setup/#continuous-integration-setup","text":"Obviously if we checked in a json file with our secrets it would negate the entire point of trying to secure our code base. The Build Tools include a Build Host Secrets task that executes prior to the Secrets Generation. This task will execute when the secrets json file does not exist in an attempt to generate the missing json file. This is designed to handle secrets across multiple projects. By default we assume you have a single shared project such as a .NET Standard library, and one or more platform projects like iOS, Android, UWP, macOS, & Tizen. To override the secrets prefix for any project you simply need to provide a value for BuildHostSecretPrefix Platform Secrets Prefix Android DroidSecret_ iOS iOSSecret_ UWP UWPSecret_ macOS MacSecret_ Tizen TizenSecret_ Default Secret_","title":"Continuous Integration Setup"},{"location":"images/","text":"Image Asset Generation \u00b6 It takes about 5 minutes as a Mobile developer until you realize that Mobile apps have a lot of image assets. If you're a Cross Platform developer you realize that with your doubled reach comes a doubling of the amount of image assets you need to track. One of the premiere features of the Mobile.BuildTools in version 2 is the ability to handle custom asset generation. We do this by only tracking or letting you worry about the Full Resolution image assets that you want as part of your app. Important It is extremely important to note that the Image Processing features listed here are largely WIP guidance on how these features are intended to work. As Image Processing is still very much WIP, not everything listed here may currently be functioning as expected. Adding Image Search Directories \u00b6 The Mobile.BuildTools allows you to bring in images within one or more directories in 3 different ways: Directories that should be searched for all builds { \"images\" : { \"directories\" : [ \"Images\" ] } } Directories that should conditionally be searched. See Conditional Directories for more information. { \"images\" : { \"conditionalDirectories\" : { \"someCondition\" : [ \"AnotherDirectory\" ] } } } MSBuild Configured Directories typically used in CI which can optionally override your json configuration. See the Build Customization topic for more information. Warning The Mobile.BuildTools will only evaluate images in the top level of the specified directories. Images in subdirectories will be ignored unless otherwise specified as a search directory or conditional directory. Conditional Directories \u00b6 Conditional Directories supercharges your ability deliver customized images for your apps. The Conditional Directories help us to get a better handle on what image assets we want to include either for a specified Target Platform or Build Configuration. Supported Conditions \u00b6 Platform Conditions Xamarin.iOS MonoAndroid Build Configurations Any Build Configuration you have! Optionally negate a Condition like !Debug { \"images\" : { \"directories\" : [ \"Images\" , \"Images\\\\Shared\" ], \"conditionalDirectories\" : { \"MonoAndroid\" : [ \"Images\\\\Android\" ], \"Xamarin.iOS\" : [ \"Images\\\\iOS\" ], \"Debug\" : [ \"Images\\\\Debug\" ], \"!Store\" : [ \"Images\\\\NotProduction\" ], \"Store\" : [ \"Images\\\\Production\" ] } } } Sample Outputs \u00b6 Using Conditional Directories along with the ability to watermark images (see Configuring Images topic) you can easily transform images. For this let's say that we have two watermark images that we want to use on one or more of the images that will be used in our app. Let's next say that we have two images we want to test this on like the following: Important You may have noticed from looking at these images that all of the images are different resolutions. The Mobile.BuildTools is smart enough to understand that we want to scale your watermark and your input image to share the same canvas size. We will then generate the appropriate output size based on what your needs are. Limitations \u00b6 Keep in mind that we do require that each image have a sibling json configuration file. This means that if your image is at the path: Images\\foo.png , then we would expect a configuration at Images\\foo.json , even if that file is an empty JSON file. When using Conditional Directories it is very much possible that you would have more than one json configuration file for a single image. The Mobile.BuildTools will ignore the sibling configuration any time a second json configuration file is found in another directory. Warning While the Mobile.BuildTools can handle locating 2 json configurations during a build where one of them is a sibling of the image, the Mobile.BuildTools cannot handle scenarios where you it locates more than one json configuration that is not a sibling of the image as we would not know which one is the proper one to use. Supported Platforms \u00b6 Not all platforms are supported. For more information see the grid below: Platform Status Android Supported iOS Supported macOS Supported * tvOS Supported * Tizen Not Supported - See issue #101 UWP Not Supported - See issue #100 Blazor Not Planned Web Assembly Not Planned * Platform is theoretically supported as there should be no difference from iOS, however this has not been directly tested.","title":"Getting Started"},{"location":"images/#image-asset-generation","text":"It takes about 5 minutes as a Mobile developer until you realize that Mobile apps have a lot of image assets. If you're a Cross Platform developer you realize that with your doubled reach comes a doubling of the amount of image assets you need to track. One of the premiere features of the Mobile.BuildTools in version 2 is the ability to handle custom asset generation. We do this by only tracking or letting you worry about the Full Resolution image assets that you want as part of your app. Important It is extremely important to note that the Image Processing features listed here are largely WIP guidance on how these features are intended to work. As Image Processing is still very much WIP, not everything listed here may currently be functioning as expected.","title":"Image Asset Generation"},{"location":"images/#adding-image-search-directories","text":"The Mobile.BuildTools allows you to bring in images within one or more directories in 3 different ways: Directories that should be searched for all builds { \"images\" : { \"directories\" : [ \"Images\" ] } } Directories that should conditionally be searched. See Conditional Directories for more information. { \"images\" : { \"conditionalDirectories\" : { \"someCondition\" : [ \"AnotherDirectory\" ] } } } MSBuild Configured Directories typically used in CI which can optionally override your json configuration. See the Build Customization topic for more information. Warning The Mobile.BuildTools will only evaluate images in the top level of the specified directories. Images in subdirectories will be ignored unless otherwise specified as a search directory or conditional directory.","title":"Adding Image Search Directories"},{"location":"images/#conditional-directories","text":"Conditional Directories supercharges your ability deliver customized images for your apps. The Conditional Directories help us to get a better handle on what image assets we want to include either for a specified Target Platform or Build Configuration.","title":"Conditional Directories"},{"location":"images/#supported-conditions","text":"Platform Conditions Xamarin.iOS MonoAndroid Build Configurations Any Build Configuration you have! Optionally negate a Condition like !Debug { \"images\" : { \"directories\" : [ \"Images\" , \"Images\\\\Shared\" ], \"conditionalDirectories\" : { \"MonoAndroid\" : [ \"Images\\\\Android\" ], \"Xamarin.iOS\" : [ \"Images\\\\iOS\" ], \"Debug\" : [ \"Images\\\\Debug\" ], \"!Store\" : [ \"Images\\\\NotProduction\" ], \"Store\" : [ \"Images\\\\Production\" ] } } }","title":"Supported Conditions"},{"location":"images/#sample-outputs","text":"Using Conditional Directories along with the ability to watermark images (see Configuring Images topic) you can easily transform images. For this let's say that we have two watermark images that we want to use on one or more of the images that will be used in our app. Let's next say that we have two images we want to test this on like the following: Important You may have noticed from looking at these images that all of the images are different resolutions. The Mobile.BuildTools is smart enough to understand that we want to scale your watermark and your input image to share the same canvas size. We will then generate the appropriate output size based on what your needs are.","title":"Sample Outputs"},{"location":"images/#limitations","text":"Keep in mind that we do require that each image have a sibling json configuration file. This means that if your image is at the path: Images\\foo.png , then we would expect a configuration at Images\\foo.json , even if that file is an empty JSON file. When using Conditional Directories it is very much possible that you would have more than one json configuration file for a single image. The Mobile.BuildTools will ignore the sibling configuration any time a second json configuration file is found in another directory. Warning While the Mobile.BuildTools can handle locating 2 json configurations during a build where one of them is a sibling of the image, the Mobile.BuildTools cannot handle scenarios where you it locates more than one json configuration that is not a sibling of the image as we would not know which one is the proper one to use.","title":"Limitations"},{"location":"images/#supported-platforms","text":"Not all platforms are supported. For more information see the grid below: Platform Status Android Supported iOS Supported macOS Supported * tvOS Supported * Tizen Not Supported - See issue #101 UWP Not Supported - See issue #100 Blazor Not Planned Web Assembly Not Planned * Platform is theoretically supported as there should be no difference from iOS, however this has not been directly tested.","title":"Supported Platforms"},{"location":"images/build-customization/","text":"The image processing feature of the Mobile.BuildTools has always been built with the intention of making white labeling apps or customizing resources like app icons based on build environment easier. Because of this, in addition to configuring this feature with the buildtools.json, we also support overriding your default configuration at build using more conventional MSBuild properties. Customizing the Search Paths \u00b6 In order to customize the search paths at build you should set the Property BuildToolsImageSearchPath . This property can contain multiple paths as long as the paths can be split with a semi-colon ; . Setting the property could be as simple as the following: <PropertyGroup> <BuildToolsImageSearchPath> $(SolutionDir)\\Images\\MoreImages;$(SolutionDir)\\Images\\AwesomeImages </BuildToolsImageSearchPath> </PropertyGroup> Overriding the Json Configuration \u00b6 The Image Processing feature of the Mobile.BuildTools allows you to completely override your JSON configuration at build by specifying an additional property BuildToolsIgnoreDefaultSearchPath . By setting this property to true in the presence of any build defined search paths, we will ignore all paths including the conditional paths specified in the buildtools.json. Putting this together \u00b6 To understand how we might use this in a DevOps environment we'll look at some YAML to see how this would look with Azure Pipelines: - task : XamariniOS@2 displayName : 'Build Xamarin.iOS solution' inputs : solutionFile : 'src/AwesomeApp.iOS/AwesomeApp.iOS.csproj' configuration : ${{ parameters.buildConfiguration }} packageApp : true runNuGetRestore : true args : '/p:BuildToolsImageSearchPath= '' $(ClientImages) '' /p:BuildToolsIgnoreDefaultSearchPath=true' env : Secret_SampleString : 'Sample String' Secret_SampleInt : '1' Secret_SampleDouble : '2.1' Secret_SampleBool : 'true'","title":"Build Customization"},{"location":"images/build-customization/#customizing-the-search-paths","text":"In order to customize the search paths at build you should set the Property BuildToolsImageSearchPath . This property can contain multiple paths as long as the paths can be split with a semi-colon ; . Setting the property could be as simple as the following: <PropertyGroup> <BuildToolsImageSearchPath> $(SolutionDir)\\Images\\MoreImages;$(SolutionDir)\\Images\\AwesomeImages </BuildToolsImageSearchPath> </PropertyGroup>","title":"Customizing the Search Paths"},{"location":"images/build-customization/#overriding-the-json-configuration","text":"The Image Processing feature of the Mobile.BuildTools allows you to completely override your JSON configuration at build by specifying an additional property BuildToolsIgnoreDefaultSearchPath . By setting this property to true in the presence of any build defined search paths, we will ignore all paths including the conditional paths specified in the buildtools.json.","title":"Overriding the Json Configuration"},{"location":"images/build-customization/#putting-this-together","text":"To understand how we might use this in a DevOps environment we'll look at some YAML to see how this would look with Azure Pipelines: - task : XamariniOS@2 displayName : 'Build Xamarin.iOS solution' inputs : solutionFile : 'src/AwesomeApp.iOS/AwesomeApp.iOS.csproj' configuration : ${{ parameters.buildConfiguration }} packageApp : true runNuGetRestore : true args : '/p:BuildToolsImageSearchPath= '' $(ClientImages) '' /p:BuildToolsIgnoreDefaultSearchPath=true' env : Secret_SampleString : 'Sample String' Secret_SampleInt : '1' Secret_SampleDouble : '2.1' Secret_SampleBool : 'true'","title":"Putting this together"},{"location":"images/built-in-templates/","text":"When using the built in drawing API in the Mobile.BuildTools, we will draw one a custom banner and text in one of 6 layouts. Top Left Top Top Right Bottom Left Bottom Bottom Right What can you edit? Use your specified text Use any system installed font Use a custom font from a specified font file Specify the Text Color Specify One or More Colors for the Banner to get your preferred style (solid or gradient)","title":"Built In Templates"},{"location":"images/configuring-images/","text":"The first time the Mobile.BuildTools encounters an image it will automatically generate a default image configuration file along side of the image. This file is what allows you to customize and further refine the image that you want. A configuration file may reside a conditional search directory. The Mobile.BuildTools will opt to use a configuration that is not in the same file directory as the image resource any time that a duplication is found. Warning Keep in mind that we only ever support a scenario where you have a single configuration in a directory other than the original image. In the event that two or more configurations are found for the same image in directories other than the directory where the image is located the Mobile.BuildTools will throw an exception causing a Build Error. Note If you have an image name that contains white space such as foo bar.png , the Mobile.BuildTools will sanitize the file name replace any contiguous white space characters with a single - . This normalization is required by Android and will mean that you will need to reference the image as foo-bar.png . Configuring Images \u00b6 The Schema for configuring images is rather simple by design. We allow you to specify a watermark file name, a name, a scale and an optional ignore. To start let's consider that we have an image named Mobile-BuildTools.png . We know that we cannot get away with this file name on all platforms so we want to rename the generated image. { \"$schema\" : \"http://mobilebuildtools.com/schemas/v2/resourceDefinition.schema.json\" , \"name\" : \"mobile_buildtools\" } The above sample would allow us to have a resource named mobile_buildtools when we refer to this from our Xamarin code. Platform Specific Configurations \u00b6 There is a common schema for image configuration which includes the following properties: { \"$schema\" : \"http://mobilebuildtools.com/schemas/v2/resourceDefinition.schema.json\" , \"name\" : \"someName\" , \"scale\" : 0.875 , \"backgroundColor\" : \"#ffffff\" , \"ignore\" : false , } This schema is available generally for each image and can be used to further tweak or customize for the platform. As an example let's consider that we want the Mobile-BuildTools.png to be used as the app icon. We will want to use the App Icon Set on iOS named AppIcon and we'll want to use the image name icon on Android. To accomplish this our configuration would look like: { \"$schema\" : \"http://mobilebuildtools.com/schemas/v2/resourceDefinition.schema.json\" , \"android\" : { \"name\" : \"icon\" }, \"apple\" : { \"name\" : \"AppIcon\" } } Let's now consider a few facts about our icon that would be quite common, particularly when sharing the same resource between iOS and Android for the App Icon. We want the Android resource to be in the mipmap folder rather the drawable folders Our full size image is much larger than the full size icon should be for Android Our image has a transparent background which will need to be adjusted on iOS Given these additional criteria we would want to update our configuration as follows: { \"$schema\" : \"http://mobilebuildtools.com/schemas/v2/resourceDefinition.schema.json\" , \"android\" : { \"name\" : \"icon\" , \"resourceType\" : \"Mipmap\" , \"scale\" : 0.375 }, \"apple\" : { \"name\" : \"AppIcon\" , \"backgroundColor\" : \"#fc7e00\" } } Note Android specific configuration defines an additional property for the Resource Type. By default this is set to Drawable. You can however change this in your image configuration for mipmap resources. Watermarking Images \u00b6 One of the great things that the Mobile.BuildTools supports is watermarking images at build. This is a very powerful feature as shown below. To configure images for Watermarking there are a few simple steps that you will need to take. Let's first make a couple of assumptions. You have your base resources in the path Images This includes an image asset called icon.png You have a subfolder called Images\\Debug Inside of this directory you have a watermark file called beta-version.png In order to set this up our buildtools.json might look like this: { \"images\" : { \"directories\" : [ \"Images\" ], \"conditionalDirectories\" : { \"Debug\" : [ \"Images\\\\Debug\" ] } } } icon.png beta-version.png output: icon.png When the Mobile.BuildTools runs and the Image collector locates an image, it will automatically generate a default JSON configuration file. The configuration file must have the same name as the image without the file extension. As a result after the first run our output image will look exactly the same as our input image only resized, and we would also have an asset added for the beta-version.png although this was not what we had wanted. The file system will also now contain the new files Images\\icon.json & Images\\Debug\\beta-version.json . You will not need to do anything to the Images\\icon.json file, however you will want to copy this to Images\\Debug directory. Next you'll want to open a text editor such as Visual Studio Code which will automatically pick up the schema referenced in the generated file and give you intellisense as you work on the file. We'll update the following two files as follows: Images\\Debug\\beta-version.json { \"$schema\" : \"http://mobilebuildtools.com/schemas/v2/resourceDefinition.schema.json\" , \"ignore\" : true } Images\\Debug\\icon.json { \"$schema\" : \"http://mobilebuildtools.com/schemas/v2/resourceDefinition.schema.json\" , \"watermark\" : { \"sourceFile\" : \"beta-version\" } } Warning When using Conditional Directories to modify images with watermarks be sure that there is never more than one conditional configuration included. Doing so will result in a build error as the Mobile.BuildTools has no way of know which conditional configuration to use. With our updated configurations we can now rebuild and the Mobile.BuildTools will generally ignore the beta-version.png as an asset of it's own while it will apply the beta-version.png as an overlay to our icon during our debug builds. Drawn Watermarks \u00b6 Just like mentioned above we can provide a configuration file for our image in a conditional directory to use the full watermarking power without having to have any specific image resource for our overlay. The Mobile.BuildTools provides a built in powerful drawing API with 6 different layout options and complete customization of the text, font and colors used. { \"watermark\" : { \"colors\" : [ \"Purple\" , \"#008888\" ], \"text\" : \"Dev\" , \"fontFamily\" : \"Times New Roman\" , \"opacity\" : 0.85 } }","title":"Configuring Images"},{"location":"images/configuring-images/#configuring-images","text":"The Schema for configuring images is rather simple by design. We allow you to specify a watermark file name, a name, a scale and an optional ignore. To start let's consider that we have an image named Mobile-BuildTools.png . We know that we cannot get away with this file name on all platforms so we want to rename the generated image. { \"$schema\" : \"http://mobilebuildtools.com/schemas/v2/resourceDefinition.schema.json\" , \"name\" : \"mobile_buildtools\" } The above sample would allow us to have a resource named mobile_buildtools when we refer to this from our Xamarin code.","title":"Configuring Images"},{"location":"images/configuring-images/#platform-specific-configurations","text":"There is a common schema for image configuration which includes the following properties: { \"$schema\" : \"http://mobilebuildtools.com/schemas/v2/resourceDefinition.schema.json\" , \"name\" : \"someName\" , \"scale\" : 0.875 , \"backgroundColor\" : \"#ffffff\" , \"ignore\" : false , } This schema is available generally for each image and can be used to further tweak or customize for the platform. As an example let's consider that we want the Mobile-BuildTools.png to be used as the app icon. We will want to use the App Icon Set on iOS named AppIcon and we'll want to use the image name icon on Android. To accomplish this our configuration would look like: { \"$schema\" : \"http://mobilebuildtools.com/schemas/v2/resourceDefinition.schema.json\" , \"android\" : { \"name\" : \"icon\" }, \"apple\" : { \"name\" : \"AppIcon\" } } Let's now consider a few facts about our icon that would be quite common, particularly when sharing the same resource between iOS and Android for the App Icon. We want the Android resource to be in the mipmap folder rather the drawable folders Our full size image is much larger than the full size icon should be for Android Our image has a transparent background which will need to be adjusted on iOS Given these additional criteria we would want to update our configuration as follows: { \"$schema\" : \"http://mobilebuildtools.com/schemas/v2/resourceDefinition.schema.json\" , \"android\" : { \"name\" : \"icon\" , \"resourceType\" : \"Mipmap\" , \"scale\" : 0.375 }, \"apple\" : { \"name\" : \"AppIcon\" , \"backgroundColor\" : \"#fc7e00\" } } Note Android specific configuration defines an additional property for the Resource Type. By default this is set to Drawable. You can however change this in your image configuration for mipmap resources.","title":"Platform Specific Configurations"},{"location":"images/configuring-images/#watermarking-images","text":"One of the great things that the Mobile.BuildTools supports is watermarking images at build. This is a very powerful feature as shown below. To configure images for Watermarking there are a few simple steps that you will need to take. Let's first make a couple of assumptions. You have your base resources in the path Images This includes an image asset called icon.png You have a subfolder called Images\\Debug Inside of this directory you have a watermark file called beta-version.png In order to set this up our buildtools.json might look like this: { \"images\" : { \"directories\" : [ \"Images\" ], \"conditionalDirectories\" : { \"Debug\" : [ \"Images\\\\Debug\" ] } } } icon.png beta-version.png output: icon.png When the Mobile.BuildTools runs and the Image collector locates an image, it will automatically generate a default JSON configuration file. The configuration file must have the same name as the image without the file extension. As a result after the first run our output image will look exactly the same as our input image only resized, and we would also have an asset added for the beta-version.png although this was not what we had wanted. The file system will also now contain the new files Images\\icon.json & Images\\Debug\\beta-version.json . You will not need to do anything to the Images\\icon.json file, however you will want to copy this to Images\\Debug directory. Next you'll want to open a text editor such as Visual Studio Code which will automatically pick up the schema referenced in the generated file and give you intellisense as you work on the file. We'll update the following two files as follows: Images\\Debug\\beta-version.json { \"$schema\" : \"http://mobilebuildtools.com/schemas/v2/resourceDefinition.schema.json\" , \"ignore\" : true } Images\\Debug\\icon.json { \"$schema\" : \"http://mobilebuildtools.com/schemas/v2/resourceDefinition.schema.json\" , \"watermark\" : { \"sourceFile\" : \"beta-version\" } } Warning When using Conditional Directories to modify images with watermarks be sure that there is never more than one conditional configuration included. Doing so will result in a build error as the Mobile.BuildTools has no way of know which conditional configuration to use. With our updated configurations we can now rebuild and the Mobile.BuildTools will generally ignore the beta-version.png as an asset of it's own while it will apply the beta-version.png as an overlay to our icon during our debug builds.","title":"Watermarking Images"},{"location":"images/configuring-images/#drawn-watermarks","text":"Just like mentioned above we can provide a configuration file for our image in a conditional directory to use the full watermarking power without having to have any specific image resource for our overlay. The Mobile.BuildTools provides a built in powerful drawing API with 6 different layout options and complete customization of the text, font and colors used. { \"watermark\" : { \"colors\" : [ \"Purple\" , \"#008888\" ], \"text\" : \"Dev\" , \"fontFamily\" : \"Times New Roman\" , \"opacity\" : 0.85 } }","title":"Drawn Watermarks"},{"location":"manifests/","text":"App Manifests \u00b6 There are many times in which you may need to parameterize an AndroidManifest.xml or Info.plist. One such example would be when using the MSAL library for Azure Active Directory / Azure Active Directory B2C user authentication in which you must create a custom url scheme like: Critical Note While this was originally slated for v2.0, this will not be done until 2.1. <key> CFBundleURLTypes </key> <array> <dict> <key> CFBundleTypeRole </key> <string> Editor </string> <key> CFBundleURLName </key> <string> com.avantipoint.awesomeapp </string> <key> CFBundleURLSchemes </key> <array> <string> msal$AzureADClientId$ </string> </array> </dict> </array> We can now leave our Info.plist or AndroidManifest.xml checked into source control and in place in our project. The Mobile.BuildTools will intelligently replace any tokenized values like the one above during the build. { \"$schema\" : \"https://mobilebuildtools.com/schemas/v2/buildtools.schema.json\" , \"manifests\" : { \"token\" : \"$$\" , \"variablePrefix\" : \"Manifest_\" , \"missingTokensAsErrors\" : false , \"disable\" : false }, Note If no environment variable can be found matching Manifest_ as the prefix is defined, the Mobile.BuildTools will next search for a variable name matching the token name which would be AzureADClientId in the sample above. It will also try to do all matches case insensitive due to the issue with some build agents running ToUpper() on all variable names. Info In order to work with the tokenized manifest locally without having to update your Environment Variables on your developer machine, you can simply drop in a manifest.json in the Project root with the Key/Value pairs for the Mobile.BuildTools to use. If using this file, be sure to add it to the .gitignore so as to not accidently check it into source control.","title":"Tokenized Manifests"},{"location":"manifests/#app-manifests","text":"There are many times in which you may need to parameterize an AndroidManifest.xml or Info.plist. One such example would be when using the MSAL library for Azure Active Directory / Azure Active Directory B2C user authentication in which you must create a custom url scheme like: Critical Note While this was originally slated for v2.0, this will not be done until 2.1. <key> CFBundleURLTypes </key> <array> <dict> <key> CFBundleTypeRole </key> <string> Editor </string> <key> CFBundleURLName </key> <string> com.avantipoint.awesomeapp </string> <key> CFBundleURLSchemes </key> <array> <string> msal$AzureADClientId$ </string> </array> </dict> </array> We can now leave our Info.plist or AndroidManifest.xml checked into source control and in place in our project. The Mobile.BuildTools will intelligently replace any tokenized values like the one above during the build. { \"$schema\" : \"https://mobilebuildtools.com/schemas/v2/buildtools.schema.json\" , \"manifests\" : { \"token\" : \"$$\" , \"variablePrefix\" : \"Manifest_\" , \"missingTokensAsErrors\" : false , \"disable\" : false }, Note If no environment variable can be found matching Manifest_ as the prefix is defined, the Mobile.BuildTools will next search for a variable name matching the token name which would be AzureADClientId in the sample above. It will also try to do all matches case insensitive due to the issue with some build agents running ToUpper() on all variable names. Info In order to work with the tokenized manifest locally without having to update your Environment Variables on your developer machine, you can simply drop in a manifest.json in the Project root with the Key/Value pairs for the Mobile.BuildTools to use. If using this file, be sure to add it to the .gitignore so as to not accidently check it into source control.","title":"App Manifests"},{"location":"manifests/versioning/","text":"Build Versioning \u00b6 Build versioning can be extremely important for analytics and diagnostics. What's more is that Mobile development requires unique builds. No longer can you be lazy and ship apps for 15 years at Version 1.0.0.0. Ok technically all of your binaries in the application all will show that version, but the app itself must have a unique build number to allow you to upload to the App Store and Google Play. Critical Note While this was originally slated for v2.0, this will not be done until 2.1. { \"$schema\" : \"https://mobilebuildtools.com/schemas/v2/buildtools.schema.json\" , \"automaticVersioning\" : { \"behavior\" : \"PreferBuildNumber\" , \"environment\" : \"All\" , \"versionOffset\" : 0 , \"disable\" : false }, } Automatic Build Versioning supports the following Versioning Environments: Environment Description All Versioning will occur on every build. BuildHost Versioning will only occur if a *Supported Build Host is detected. Local Versioning will only occur if a *Supported Build Host is not detected. Automatic Build Versioning supports the following Behavior 's: Behavior Description Off Automatic Versioning is Disabled PreferBuildNumber When running on a *Supported Build Host it will use the Build Number, otherwise it will use the current timestamp Timestamp Automatic Versioning will use the timestamp for the build * Supported Build Hosts: AppCenter AppVeyor Azure DevOps Jenkins Info You might use the versionOffset when your CI Build Number and Build Number in the App Store or Google Play are not in sync. As an example, when shipping multiple APKs with the same build number Google Play may take build 123 and make it 100123, 200123, 300123, & 400123 respectively for each of the 4 APK's you have provided. This would mean when switching to AAB that you might need to offset by 400000 in order to get your new AAB build to show up in Google Play.","title":"Build Versioning"},{"location":"manifests/versioning/#build-versioning","text":"Build versioning can be extremely important for analytics and diagnostics. What's more is that Mobile development requires unique builds. No longer can you be lazy and ship apps for 15 years at Version 1.0.0.0. Ok technically all of your binaries in the application all will show that version, but the app itself must have a unique build number to allow you to upload to the App Store and Google Play. Critical Note While this was originally slated for v2.0, this will not be done until 2.1. { \"$schema\" : \"https://mobilebuildtools.com/schemas/v2/buildtools.schema.json\" , \"automaticVersioning\" : { \"behavior\" : \"PreferBuildNumber\" , \"environment\" : \"All\" , \"versionOffset\" : 0 , \"disable\" : false }, } Automatic Build Versioning supports the following Versioning Environments: Environment Description All Versioning will occur on every build. BuildHost Versioning will only occur if a *Supported Build Host is detected. Local Versioning will only occur if a *Supported Build Host is not detected. Automatic Build Versioning supports the following Behavior 's: Behavior Description Off Automatic Versioning is Disabled PreferBuildNumber When running on a *Supported Build Host it will use the Build Number, otherwise it will use the current timestamp Timestamp Automatic Versioning will use the timestamp for the build * Supported Build Hosts: AppCenter AppVeyor Azure DevOps Jenkins Info You might use the versionOffset when your CI Build Number and Build Number in the App Store or Google Play are not in sync. As an example, when shipping multiple APKs with the same build number Google Play may take build 123 and make it 100123, 200123, 300123, & 400123 respectively for each of the 4 APK's you have provided. This would mean when switching to AAB that you might need to offset by 400000 in order to get your new AAB build to show up in Google Play.","title":"Build Versioning"},{"location":"scss-to-css/","text":"SCSS to Xamarin.Forms CSS \u00b6 CSS support in Xamarin.Forms is the most revolutionary change to Styling XAML. CSS though is traditionally problematic on larger projects as it can quickly become hard to maintain, and error prone as it lacks reusability of common values which could include setting various properties or reusing the same color from one element to the next. With SCSS you gain the ability to break your stylesheets into logical reusable chunks and you gain the ability to define variables and functions for creating your styles. The Mobile.BuildTools now supports Xamarin.Forms CSS generation as part of the build process. Valid Xamarin.Forms CSS \u00b6 Note The Xamarin.Forms CSS spec does not generate valid CSS and as a result SCSS will not support the use of ^. ^ button { background-color : transparent ; } . primary ^ button { background-color : #78909c ; } The Mobile.BuildTools will post process your SCSS to generate valid CSS for Xamarin.Forms when using the selectors any or all . Valid SCSS used by the Mobile.BuildTools \u00b6 button : any { background-color : transparent ; } . primary button : all { background-color : #78909c ; } Getting Started \u00b6 To get started, simply add any scss format stylesheets you want to your project and make sure that the build action is set to None . The Mobile.BuildTools will automatically detect them and generate a CSS file for each non-partial (anything not starting with an underscore). For more information on how to get started with SCSS see the Getting Started Guide from LibSass. Note Xamarin.Forms does not support minimized files","title":"General Info"},{"location":"scss-to-css/#scss-to-xamarinforms-css","text":"CSS support in Xamarin.Forms is the most revolutionary change to Styling XAML. CSS though is traditionally problematic on larger projects as it can quickly become hard to maintain, and error prone as it lacks reusability of common values which could include setting various properties or reusing the same color from one element to the next. With SCSS you gain the ability to break your stylesheets into logical reusable chunks and you gain the ability to define variables and functions for creating your styles. The Mobile.BuildTools now supports Xamarin.Forms CSS generation as part of the build process.","title":"SCSS to Xamarin.Forms CSS"},{"location":"scss-to-css/#valid-xamarinforms-css","text":"Note The Xamarin.Forms CSS spec does not generate valid CSS and as a result SCSS will not support the use of ^. ^ button { background-color : transparent ; } . primary ^ button { background-color : #78909c ; } The Mobile.BuildTools will post process your SCSS to generate valid CSS for Xamarin.Forms when using the selectors any or all .","title":"Valid Xamarin.Forms CSS"},{"location":"scss-to-css/#valid-scss-used-by-the-mobilebuildtools","text":"button : any { background-color : transparent ; } . primary button : all { background-color : #78909c ; }","title":"Valid SCSS used by the Mobile.BuildTools"},{"location":"scss-to-css/#getting-started","text":"To get started, simply add any scss format stylesheets you want to your project and make sure that the build action is set to None . The Mobile.BuildTools will automatically detect them and generate a CSS file for each non-partial (anything not starting with an underscore). For more information on how to get started with SCSS see the Getting Started Guide from LibSass. Note Xamarin.Forms does not support minimized files","title":"Getting Started"},{"location":"scss-to-css/css-notes/","text":"Supported Selectors \u00b6 Selector Example Description .class .header Selects all elements with the StyleClass property containing 'header' #id #email Selects all elements with StyleId set to email. If StyleId is not set, fallback to x:Name. When using Xaml, always prefer x:Name over StyleId. * * Selects all elements element label Selects all elements of type Label (but not subclasses). Case irrelevant. ^base ^contentpage Selects all elements with ContentPage as base class, including ContentPage itself. Case irrelevant. This selector isn't present in the CSS specification, and only applies to XF. element,element label,button Selects all Buttons and all Labels element element stacklayout label Selects all Labels inside of a StackLayout element>element stacklayout>label Selects all Labels with StackLayout as a direct parent element+element label+entry Selects all Entries directly after a Label element~element label~entry Selects all Entries preceded by a Label Unsupported Selectors (for this version) \u00b6 [attribute] selectors @media or @supports selectors : or :: selectors Selector combinations \u00b6 Selectors can be combined without limitation, like in StackLayout > ContentView > label.email. But keep it sane ! Precedence \u00b6 Styles with matching selectors are all applied, on by one, in definition order. Styles defined on the item itself is always applied last. This is the expected behavior in most cases, even if doesn't 100% match common CSS implementations. Specificity, and specificity overrides ( !important ) are not supported. This is a known issue. Unsupported Common Properties \u00b6 all: initial layout properties (box, or grid). FlexLayout is coming, and it'll be CSS stylable, shorthand properties, like font , border Colors \u00b6 one of the 140 X11 color (https://en.wikipedia.org/wiki/X11_color_names), which happens to match CSS Colors, UWP predefined colors and XF Colors. Case insensitive HEX: #rgb , #argb , #rrggbb , #aarrggbb RGB: rgb(255,0,0) , rgb(100%,0%,0%) => values in range 0-255 or 0%-100% RGBA: rgba(255, 0, 0, 0.8) , rgba(100%, 0%, 0%, 0.8) => opacity is 0.0-1.0 HSL: hsl(120, 100%, 50%) => h is 0-360, s and l are 0%-100% HSLA: hsla(120, 100%, 50%, .8) => opacity is 0.0-1.0 Thickness \u00b6 One, two, three or four values, separated by white spaces. a single value indicates uniform thickness two values indicates (resp.) vertical and horizontal thickness three values indicates (resp.) top, horizontal (left and right) and bottom thickness when using four values, they are top, right, bottom, left IMPORTANT: This differs from Xaml thickness definitions, which are separated by commas ( , ) are in the form of uniform , horizontal , vertical or left , top , right , bottom NamedSize \u00b6 One of the following value, case insensitive. Exact meaning depends of the platform and the control default micro small medium large Initial \u00b6 initial is a valid value for all properties. It clears the value (resets to default) that was set from another Style. Additional remarks \u00b6 no inheritance supported, meaning no inherit value and that you can't set the font-size to a layout, and expect all the labels in that layout to inherit the value. The only exception is the direction property, which supports inherit , and that's the default value. element are matched by name, no support for xmlns","title":"Usage Notes"},{"location":"scss-to-css/css-notes/#supported-selectors","text":"Selector Example Description .class .header Selects all elements with the StyleClass property containing 'header' #id #email Selects all elements with StyleId set to email. If StyleId is not set, fallback to x:Name. When using Xaml, always prefer x:Name over StyleId. * * Selects all elements element label Selects all elements of type Label (but not subclasses). Case irrelevant. ^base ^contentpage Selects all elements with ContentPage as base class, including ContentPage itself. Case irrelevant. This selector isn't present in the CSS specification, and only applies to XF. element,element label,button Selects all Buttons and all Labels element element stacklayout label Selects all Labels inside of a StackLayout element>element stacklayout>label Selects all Labels with StackLayout as a direct parent element+element label+entry Selects all Entries directly after a Label element~element label~entry Selects all Entries preceded by a Label","title":"Supported Selectors"},{"location":"scss-to-css/css-notes/#unsupported-selectors-for-this-version","text":"[attribute] selectors @media or @supports selectors : or :: selectors","title":"Unsupported Selectors (for this version)"},{"location":"scss-to-css/css-notes/#selector-combinations","text":"Selectors can be combined without limitation, like in StackLayout > ContentView > label.email. But keep it sane !","title":"Selector combinations"},{"location":"scss-to-css/css-notes/#precedence","text":"Styles with matching selectors are all applied, on by one, in definition order. Styles defined on the item itself is always applied last. This is the expected behavior in most cases, even if doesn't 100% match common CSS implementations. Specificity, and specificity overrides ( !important ) are not supported. This is a known issue.","title":"Precedence"},{"location":"scss-to-css/css-notes/#unsupported-common-properties","text":"all: initial layout properties (box, or grid). FlexLayout is coming, and it'll be CSS stylable, shorthand properties, like font , border","title":"Unsupported Common Properties"},{"location":"scss-to-css/css-notes/#colors","text":"one of the 140 X11 color (https://en.wikipedia.org/wiki/X11_color_names), which happens to match CSS Colors, UWP predefined colors and XF Colors. Case insensitive HEX: #rgb , #argb , #rrggbb , #aarrggbb RGB: rgb(255,0,0) , rgb(100%,0%,0%) => values in range 0-255 or 0%-100% RGBA: rgba(255, 0, 0, 0.8) , rgba(100%, 0%, 0%, 0.8) => opacity is 0.0-1.0 HSL: hsl(120, 100%, 50%) => h is 0-360, s and l are 0%-100% HSLA: hsla(120, 100%, 50%, .8) => opacity is 0.0-1.0","title":"Colors"},{"location":"scss-to-css/css-notes/#thickness","text":"One, two, three or four values, separated by white spaces. a single value indicates uniform thickness two values indicates (resp.) vertical and horizontal thickness three values indicates (resp.) top, horizontal (left and right) and bottom thickness when using four values, they are top, right, bottom, left IMPORTANT: This differs from Xaml thickness definitions, which are separated by commas ( , ) are in the form of uniform , horizontal , vertical or left , top , right , bottom","title":"Thickness"},{"location":"scss-to-css/css-notes/#namedsize","text":"One of the following value, case insensitive. Exact meaning depends of the platform and the control default micro small medium large","title":"NamedSize"},{"location":"scss-to-css/css-notes/#initial","text":"initial is a valid value for all properties. It clears the value (resets to default) that was set from another Style.","title":"Initial"},{"location":"scss-to-css/css-notes/#additional-remarks","text":"no inheritance supported, meaning no inherit value and that you can't set the font-size to a layout, and expect all the labels in that layout to inherit the value. The only exception is the direction property, which supports inherit , and that's the default value. element are matched by name, no support for xmlns","title":"Additional remarks"},{"location":"scss-to-css/in-code/","text":"XAML (preferred) \u00b6 <ContentPage x:Class= \"...\" > <ContentPage.Resources> <StyleSheet Source= \"appresources/style.css\" /> </ContentPage.Resources> </ContentPage> the Source argument takes an Uri relative to the current xaml control, or relative to the application root if it starts with a / . The style.css has to be an EmbeddedResource. alternatively, you can inline your style in a CDATA Section <ContentPage x:Class= \"...\" > <ContentPage.Resources> <StyleSheet> <![CDATA[ ^contentpage { background-color: orange; padding: 20; } stacklayout > * { margin: 3; } ]]> </StyleSheet> </ContentPage.Resources> </ContentPage> do not abuse of that second syntax. in C \u00b6 From an embedded resource: myPage . Resources . Add ( StyleSheet . FromAssemblyResource ( this . GetType (). Assembly , \"resource.id.of.the.css\" )); or from a TextReader: using ( var reader = new StringReader ( my_css_string )) myPage . Resources . Add ( StyleSheet . FromReader ( reader )); StyleSheet, XamlC and other potential optimizations \u00b6 At this time, CSS StyleSheets are parsed and evaluated at runtime. That aren't compiled. Every time a StyleSheet is used, it's reparsed again. If parsing time is an issue, enabling caching is trivial, but comes at memory cost.","title":"In Code"},{"location":"scss-to-css/in-code/#xaml-preferred","text":"<ContentPage x:Class= \"...\" > <ContentPage.Resources> <StyleSheet Source= \"appresources/style.css\" /> </ContentPage.Resources> </ContentPage> the Source argument takes an Uri relative to the current xaml control, or relative to the application root if it starts with a / . The style.css has to be an EmbeddedResource. alternatively, you can inline your style in a CDATA Section <ContentPage x:Class= \"...\" > <ContentPage.Resources> <StyleSheet> <![CDATA[ ^contentpage { background-color: orange; padding: 20; } stacklayout > * { margin: 3; } ]]> </StyleSheet> </ContentPage.Resources> </ContentPage> do not abuse of that second syntax.","title":"XAML (preferred)"},{"location":"scss-to-css/in-code/#in-c","text":"From an embedded resource: myPage . Resources . Add ( StyleSheet . FromAssemblyResource ( this . GetType (). Assembly , \"resource.id.of.the.css\" )); or from a TextReader: using ( var reader = new StringReader ( my_css_string )) myPage . Resources . Add ( StyleSheet . FromReader ( reader ));","title":"in C"},{"location":"scss-to-css/in-code/#stylesheet-xamlc-and-other-potential-optimizations","text":"At this time, CSS StyleSheets are parsed and evaluated at runtime. That aren't compiled. Every time a StyleSheet is used, it's reparsed again. If parsing time is an issue, enabling caching is trivial, but comes at memory cost.","title":"StyleSheet, XamlC and other potential optimizations"},{"location":"scss-to-css/properties/","text":"Property Applies To Value Type / Info background-color VisualElement BackgroundColorProperty background-image Page BackgroundImageSourceProperty border-color IBorderElement BorderColorProperty border-radius ICornerElement CornerRadiusProperty border-radius Button CornerRadiusProperty border-radius Frame CornerRadiusProperty border-radius ImageButton CornerRadiusProperty border-width IBorderElement BorderWidthProperty color IColorElement ColorProperty, Inherited = true color ITextElement TextColorProperty, Inherited = true color ProgressBar ProgressBar.ProgressColorProperty color Switch OnColorProperty column-gap Grid ColumnSpacingProperty direction VisualElement FlowDirectionProperty, Inherited = true font-family IFontElement FontFamilyProperty, Inherited = true font-size IFontElement FontSizeProperty, Inherited = true font-style IFontElement FontAttributesProperty, Inherited = true height VisualElement HeightRequestProperty margin View View.MarginProperty margin-left View View.MarginLeftProperty margin-top View View.MarginTopProperty margin-right View View.MarginRightProperty margin-bottom View View.MarginBottomProperty max-lines Label Label.MaxLinesProperty min-height VisualElement MinimumHeightRequestProperty min-width VisualElement MinimumWidthRequestProperty opacity VisualElement OpacityProperty padding IPaddingElement PaddingProperty padding-left IPaddingElement PaddingLeftProperty, PropertyOwnerType = PaddingElement padding-top IPaddingElement PaddingTopProperty, PropertyOwnerType = PaddingElement padding-right IPaddingElement PaddingRightProperty, PropertyOwnerType = PaddingElement padding-bottom IPaddingElement PaddingBottomProperty, PropertyOwnerType = PaddingElement row-gap Grid RowSpacingProperty text-align ITextAlignmentElement HorizontalTextAlignmentProperty, Inherited = true text-decoration IDecorableTextElement DecorableTextElement.TextDecorationsProperty transform VisualElement TransformProperty transform-origin VisualElement TransformOriginProperty vertical-align ITextAlignmentElement VerticalTextAlignmentProperty visibility VisualElement IsVisibleProperty, Inherited = true width VisualElement WidthRequestProperty letter-spacing ITextElement CharacterSpacingProperty, Inherited = true line-height ILineHeightElement LineHeightProperty, Inherited = true FlexLayout \u00b6 Property Applies To Value Type / Info align-content FlexLayout AlignContentProperty align-items FlexLayout AlignItemsProperty align-self VisualElement AlignSelfProperty, PropertyOwnerType = FlexLayout flex-direction FlexLayout DirectionProperty flex-basis VisualElement BasisProperty, PropertyOwnerType = FlexLayout flex-grow VisualElement GrowProperty, PropertyOwnerType = FlexLayout flex-shrink VisualElement ShrinkProperty, PropertyOwnerType = FlexLayout flex-wrap VisualElement WrapProperty, PropertyOwnerType = FlexLayout justify-content FlexLayout JustifyContentProperty order VisualElement OrderProperty, PropertyOwnerType = FlexLayout position FlexLayout PositionProperty Xamarin.Forms Specific Properties \u00b6 Property Applies To Value Type / Info -xf-placeholder IPlaceholderElement PlaceholderProperty -xf-placeholder-color IPlaceholderElement PlaceholderColorProperty -xf-max-length InputView MaxLengthProperty -xf-bar-background-color IBarElement BarBackgroundColorProperty -xf-bar-text-color IBarElement BarTextColorProperty -xf-orientation ScrollView OrientationProperty -xf-horizontal-scroll-bar-visibility ScrollView HorizontalScrollBarVisibilityProperty -xf-vertical-scroll-bar-visibility ScrollView VerticalScrollBarVisibilityProperty -xf-min-track-color Slider MinimumTrackColorProperty -xf-max-track-color Slider MaximumTrackColorProperty -xf-thumb-color Slider ThumbColorProperty -xf-spacing StackLayout SpacingProperty -xf-orientation StackLayout OrientationProperty -xf-visual VisualElement VisualProperty -xf-vertical-text-alignment Label VerticalTextAlignmentProperty -xf-thumb-color Switch ThumbColorProperty Shell Specific Properties \u00b6 Property Applies To Value Type / Info -xf-flyout-background Shell FlyoutBackgroundColorProperty -xf-shell-background Element BackgroundColorProperty, PropertyOwnerType = Shell -xf-shell-disabled Element DisabledColorProperty, PropertyOwnerType = Shell -xf-shell-foreground Element ForegroundColorProperty, PropertyOwnerType = Shell -xf-shell-tabbar-background Element TabBarBackgroundColorProperty, PropertyOwnerType = Shell -xf-shell-tabbar-disabled Element TabBarDisabledColorProperty, PropertyOwnerType = Shell -xf-shell-tabbar-foreground Element TabBarForegroundColorProperty, PropertyOwnerType = Shell -xf-shell-tabbar-title Element TabBarTitleColorProperty, PropertyOwnerType = Shell -xf-shell-tabbar-unselected Element TabBarUnselectedColorProperty, PropertyOwnerType = Shell -xf-shell-title Element TitleColorProperty, PropertyOwnerType = Shell -xf-shell-unselected Element UnselectedColorProperty, PropertyOwnerType = Shell","title":"Supported Properties"},{"location":"scss-to-css/properties/#flexlayout","text":"Property Applies To Value Type / Info align-content FlexLayout AlignContentProperty align-items FlexLayout AlignItemsProperty align-self VisualElement AlignSelfProperty, PropertyOwnerType = FlexLayout flex-direction FlexLayout DirectionProperty flex-basis VisualElement BasisProperty, PropertyOwnerType = FlexLayout flex-grow VisualElement GrowProperty, PropertyOwnerType = FlexLayout flex-shrink VisualElement ShrinkProperty, PropertyOwnerType = FlexLayout flex-wrap VisualElement WrapProperty, PropertyOwnerType = FlexLayout justify-content FlexLayout JustifyContentProperty order VisualElement OrderProperty, PropertyOwnerType = FlexLayout position FlexLayout PositionProperty","title":"FlexLayout"},{"location":"scss-to-css/properties/#xamarinforms-specific-properties","text":"Property Applies To Value Type / Info -xf-placeholder IPlaceholderElement PlaceholderProperty -xf-placeholder-color IPlaceholderElement PlaceholderColorProperty -xf-max-length InputView MaxLengthProperty -xf-bar-background-color IBarElement BarBackgroundColorProperty -xf-bar-text-color IBarElement BarTextColorProperty -xf-orientation ScrollView OrientationProperty -xf-horizontal-scroll-bar-visibility ScrollView HorizontalScrollBarVisibilityProperty -xf-vertical-scroll-bar-visibility ScrollView VerticalScrollBarVisibilityProperty -xf-min-track-color Slider MinimumTrackColorProperty -xf-max-track-color Slider MaximumTrackColorProperty -xf-thumb-color Slider ThumbColorProperty -xf-spacing StackLayout SpacingProperty -xf-orientation StackLayout OrientationProperty -xf-visual VisualElement VisualProperty -xf-vertical-text-alignment Label VerticalTextAlignmentProperty -xf-thumb-color Switch ThumbColorProperty","title":"Xamarin.Forms Specific Properties"},{"location":"scss-to-css/properties/#shell-specific-properties","text":"Property Applies To Value Type / Info -xf-flyout-background Shell FlyoutBackgroundColorProperty -xf-shell-background Element BackgroundColorProperty, PropertyOwnerType = Shell -xf-shell-disabled Element DisabledColorProperty, PropertyOwnerType = Shell -xf-shell-foreground Element ForegroundColorProperty, PropertyOwnerType = Shell -xf-shell-tabbar-background Element TabBarBackgroundColorProperty, PropertyOwnerType = Shell -xf-shell-tabbar-disabled Element TabBarDisabledColorProperty, PropertyOwnerType = Shell -xf-shell-tabbar-foreground Element TabBarForegroundColorProperty, PropertyOwnerType = Shell -xf-shell-tabbar-title Element TabBarTitleColorProperty, PropertyOwnerType = Shell -xf-shell-tabbar-unselected Element TabBarUnselectedColorProperty, PropertyOwnerType = Shell -xf-shell-title Element TitleColorProperty, PropertyOwnerType = Shell -xf-shell-unselected Element UnselectedColorProperty, PropertyOwnerType = Shell","title":"Shell Specific Properties"}]}